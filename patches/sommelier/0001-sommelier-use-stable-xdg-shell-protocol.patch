From 1ae8608ed3012271d02a12abf976de824327900d Mon Sep 17 00:00:00 2001
From: Puck Meerburg <puck@puckipedia.com>
Date: Tue, 3 Dec 2019 18:06:14 +0000
Subject: [PATCH] sommelier: use stable xdg-shell protocol

From https://github.com/wayland-project/weston/commit/d8d9f5e6e16c8f6a3c06763d5f56c27dc9a6e52e:

> Some clients like the mpv video player now request the xdg_shell
> protocol so these will fail if the compositor only provides the
> xdg_shell_unstable_v6 protocol. Compositors like mir and gnome provide
> both protocols.

Rebase

Change-Id: If601a52d7bb42acea9e88de75daf8bb1e34e25dc
Signed-off-by: Kalyan Kondapally <kalyan.kondapally@intel.com>
---
 vm_tools/sommelier/BUILD.gn                   |   2 +-
 vm_tools/sommelier/meson.build                |   2 +-
 ...dg-shell-unstable-v6.xml => xdg-shell.xml} | 319 ++++++++++++------
 vm_tools/sommelier/sommelier-xdg-shell.c      | 233 ++++++-------
 vm_tools/sommelier/sommelier.c                | 211 ++++++------
 vm_tools/sommelier/sommelier.h                |  17 +-
 6 files changed, 448 insertions(+), 336 deletions(-)
 rename vm_tools/sommelier/protocol/{xdg-shell-unstable-v6.xml => xdg-shell.xml} (79%)

diff --git a/vm_tools/sommelier/BUILD.gn b/vm_tools/sommelier/BUILD.gn
index 496aad7e7..611bb127a 100644
--- a/vm_tools/sommelier/BUILD.gn
+++ b/vm_tools/sommelier/BUILD.gn
@@ -64,7 +64,7 @@ wayland_protocol_library("sommelier-protocol") {
     "protocol/relative-pointer-unstable-v1.xml",
     "protocol/text-input-unstable-v1.xml",
     "protocol/viewporter.xml",
-    "protocol/xdg-shell-unstable-v6.xml",
+    "protocol/xdg-shell.xml",
   ]
 }
 
diff --git a/vm_tools/sommelier/meson.build b/vm_tools/sommelier/meson.build
index 400a83134..62072cec0 100644
--- a/vm_tools/sommelier/meson.build
+++ b/vm_tools/sommelier/meson.build
@@ -54,7 +54,7 @@ wl_protocols = [
     'protocol/relative-pointer-unstable-v1.xml',
     'protocol/text-input-unstable-v1.xml',
     'protocol/viewporter.xml',
-    'protocol/xdg-shell-unstable-v6.xml',
+    'protocol/xdg-shell.xml',
 ]
 
 wl_outs = []
diff --git a/vm_tools/sommelier/protocol/xdg-shell-unstable-v6.xml b/vm_tools/sommelier/protocol/xdg-shell.xml
similarity index 79%
rename from vm_tools/sommelier/protocol/xdg-shell-unstable-v6.xml
rename to vm_tools/sommelier/protocol/xdg-shell.xml
index 1c0f92452..3a87a9ed6 100644
--- a/vm_tools/sommelier/protocol/xdg-shell-unstable-v6.xml
+++ b/vm_tools/sommelier/protocol/xdg-shell.xml
@@ -1,11 +1,13 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<protocol name="xdg_shell_unstable_v6">
+<protocol name="xdg_shell">
 
   <copyright>
     Copyright © 2008-2013 Kristian Høgsberg
     Copyright © 2013      Rafael Antognolli
     Copyright © 2013      Jasper St. Pierre
     Copyright © 2010-2013 Intel Corporation
+    Copyright © 2015-2017 Samsung Electronics Co., Ltd
+    Copyright © 2015-2017 Red Hat Inc.
 
     Permission is hereby granted, free of charge, to any person obtaining a
     copy of this software and associated documentation files (the "Software"),
@@ -27,18 +29,19 @@
     DEALINGS IN THE SOFTWARE.
   </copyright>
 
-  <interface name="zxdg_shell_v6" version="1">
+  <interface name="xdg_wm_base" version="2">
     <description summary="create desktop-style surfaces">
-      xdg_shell allows clients to turn a wl_surface into a "real window"
-      which can be dragged, resized, stacked, and moved around by the
-      user. Everything about this interface is suited towards traditional
-      desktop environments.
+      The xdg_wm_base interface is exposed as a global object enabling clients
+      to turn their wl_surfaces into windows in a desktop environment. It
+      defines the basic functionality needed for clients and the compositor to
+      create windows that can be dragged, resized, maximized, etc, as well as
+      creating transient windows such as popup menus.
     </description>
 
     <enum name="error">
       <entry name="role" value="0" summary="given wl_surface has another role"/>
       <entry name="defunct_surfaces" value="1"
-	     summary="xdg_shell was destroyed before children"/>
+	     summary="xdg_wm_base was destroyed before children"/>
       <entry name="not_the_topmost_popup" value="2"
 	     summary="the client tried to map or destroy a non-topmost popup"/>
       <entry name="invalid_popup_parent" value="3"
@@ -50,11 +53,11 @@
     </enum>
 
     <request name="destroy" type="destructor">
-      <description summary="destroy xdg_shell">
-	Destroy this xdg_shell object.
+      <description summary="destroy xdg_wm_base">
+	Destroy this xdg_wm_base object.
 
-	Destroying a bound xdg_shell object while there are surfaces
-	still alive created by this xdg_shell object instance is illegal
+	Destroying a bound xdg_wm_base object while there are surfaces
+	still alive created by this xdg_wm_base object instance is illegal
 	and will result in a protocol error.
       </description>
     </request>
@@ -65,7 +68,7 @@
 	surfaces relative to some parent surface. See the interface description
 	and xdg_surface.get_popup for details.
       </description>
-      <arg name="id" type="new_id" interface="zxdg_positioner_v6"/>
+      <arg name="id" type="new_id" interface="xdg_positioner"/>
     </request>
 
     <request name="get_xdg_surface">
@@ -82,14 +85,14 @@
 	See the documentation of xdg_surface for more details about what an
 	xdg_surface is and how it is used.
       </description>
-      <arg name="id" type="new_id" interface="zxdg_surface_v6"/>
+      <arg name="id" type="new_id" interface="xdg_surface"/>
       <arg name="surface" type="object" interface="wl_surface"/>
     </request>
 
     <request name="pong">
       <description summary="respond to a ping event">
 	A client must respond to a ping event with a pong request or
-	the client may be deemed unresponsive. See xdg_shell.ping.
+	the client may be deemed unresponsive. See xdg_wm_base.ping.
       </description>
       <arg name="serial" type="uint" summary="serial of the ping event"/>
     </request>
@@ -98,7 +101,7 @@
       <description summary="check if the client is alive">
 	The ping event asks the client if it's still alive. Pass the
 	serial specified in the event back to the compositor by sending
-	a "pong" request back with the specified serial. See xdg_shell.ping.
+	a "pong" request back with the specified serial. See xdg_wm_base.pong.
 
 	Compositors can use this to determine if the client is still
 	alive. It's unspecified what will happen if the client doesn't
@@ -106,13 +109,13 @@
 	try to respond in a reasonable amount of time.
 
 	A compositor is free to ping in any way it wants, but a client must
-	always respond to any xdg_shell object it created.
+	always respond to any xdg_wm_base object it created.
       </description>
       <arg name="serial" type="uint" summary="pass this to the pong request"/>
     </event>
   </interface>
 
-  <interface name="zxdg_positioner_v6" version="1">
+  <interface name="xdg_positioner" version="2">
     <description summary="child surface positioner">
       The xdg_positioner provides a collection of rules for the placement of a
       child surface relative to a parent surface. Rules can be defined to ensure
@@ -162,13 +165,13 @@
 	Specify the anchor rectangle within the parent surface that the child
 	surface will be placed relative to. The rectangle is relative to the
 	window geometry as defined by xdg_surface.set_window_geometry of the
-	parent surface. The rectangle must be at least 1x1 large.
+	parent surface.
 
 	When the xdg_positioner object is used to position a child surface, the
 	anchor rectangle may not extend outside the window geometry of the
 	positioned child's parent surface.
 
-	If a zero or negative size is set the invalid_input error is raised.
+	If a negative size is set the invalid_input error is raised.
       </description>
       <arg name="x" type="int" summary="x position of anchor rectangle"/>
       <arg name="y" type="int" summary="y position of anchor rectangle"/>
@@ -176,63 +179,54 @@
       <arg name="height" type="int" summary="height of anchor rectangle"/>
     </request>
 
-    <enum name="anchor" bitfield="true">
-      <entry name="none" value="0"
-	     summary="the center of the anchor rectangle"/>
-      <entry name="top" value="1"
-	     summary="the top edge of the anchor rectangle"/>
-      <entry name="bottom" value="2"
-	     summary="the bottom edge of the anchor rectangle"/>
-      <entry name="left" value="4"
-	     summary="the left edge of the anchor rectangle"/>
-      <entry name="right" value="8"
-	     summary="the right edge of the anchor rectangle"/>
+    <enum name="anchor">
+      <entry name="none" value="0"/>
+      <entry name="top" value="1"/>
+      <entry name="bottom" value="2"/>
+      <entry name="left" value="3"/>
+      <entry name="right" value="4"/>
+      <entry name="top_left" value="5"/>
+      <entry name="bottom_left" value="6"/>
+      <entry name="top_right" value="7"/>
+      <entry name="bottom_right" value="8"/>
     </enum>
 
     <request name="set_anchor">
-      <description summary="set anchor rectangle anchor edges">
-	Defines a set of edges for the anchor rectangle. These are used to
-	derive an anchor point that the child surface will be positioned
-	relative to. If two orthogonal edges are specified (e.g. 'top' and
-	'left'), then the anchor point will be the intersection of the edges
-	(e.g. the top left position of the rectangle); otherwise, the derived
-	anchor point will be centered on the specified edge, or in the center of
-	the anchor rectangle if no edge is specified.
-
-	If two parallel anchor edges are specified (e.g. 'left' and 'right'),
-	the invalid_input error is raised.
+      <description summary="set anchor rectangle anchor">
+	Defines the anchor point for the anchor rectangle. The specified anchor
+	is used derive an anchor point that the child surface will be
+	positioned relative to. If a corner anchor is set (e.g. 'top_left' or
+	'bottom_right'), the anchor point will be at the specified corner;
+	otherwise, the derived anchor point will be centered on the specified
+	edge, or in the center of the anchor rectangle if no edge is specified.
       </description>
       <arg name="anchor" type="uint" enum="anchor"
-	   summary="bit mask of anchor edges"/>
+	   summary="anchor"/>
     </request>
 
-    <enum name="gravity" bitfield="true">
-      <entry name="none" value="0"
-	     summary="center over the anchor edge"/>
-      <entry name="top" value="1"
-	     summary="position above the anchor edge"/>
-      <entry name="bottom" value="2"
-	     summary="position below the anchor edge"/>
-      <entry name="left" value="4"
-	     summary="position to the left of the anchor edge"/>
-      <entry name="right" value="8"
-	     summary="position to the right of the anchor edge"/>
+    <enum name="gravity">
+      <entry name="none" value="0"/>
+      <entry name="top" value="1"/>
+      <entry name="bottom" value="2"/>
+      <entry name="left" value="3"/>
+      <entry name="right" value="4"/>
+      <entry name="top_left" value="5"/>
+      <entry name="bottom_left" value="6"/>
+      <entry name="top_right" value="7"/>
+      <entry name="bottom_right" value="8"/>
     </enum>
 
     <request name="set_gravity">
       <description summary="set child surface gravity">
 	Defines in what direction a surface should be positioned, relative to
-	the anchor point of the parent surface. If two orthogonal gravities are
-	specified (e.g. 'bottom' and 'right'), then the child surface will be
-	placed in the specified direction; otherwise, the child surface will be
-	centered over the anchor point on any axis that had no gravity
-	specified.
-
-	If two parallel gravities are specified (e.g. 'left' and 'right'), the
-	invalid_input error is raised.
+	the anchor point of the parent surface. If a corner gravity is
+	specified (e.g. 'bottom_right' or 'top_left'), then the child surface
+	will be placed towards the specified gravity; otherwise, the child
+	surface will be centered over the anchor point on any axis that had no
+	gravity specified.
       </description>
       <arg name="gravity" type="uint" enum="gravity"
-	   summary="bit mask of gravity directions"/>
+	   summary="gravity direction"/>
     </request>
 
     <enum name="constraint_adjustment" bitfield="true">
@@ -252,7 +246,7 @@
       <entry name="none" value="0">
 	<description summary="don't move the child surface when constrained">
 	  Don't alter the surface position even if it is constrained on some
-	  axis, for example partially outside the edge of a monitor.
+	  axis, for example partially outside the edge of an output.
 	</description>
       </entry>
       <entry name="slide_x" value="1">
@@ -304,6 +298,10 @@
 	  surface is constrained, the gravity is 'bottom' and the anchor is
 	  'bottom', change the gravity to 'top' and the anchor to 'top'.
 
+	  The adjusted position is calculated given the original anchor
+	  rectangle and offset, but with the new flipped anchor and gravity
+	  values.
+
 	  If the adjusted position also ends up being constrained, the resulting
 	  position of the flip_y adjustment will be the one before the
 	  adjustment.
@@ -361,7 +359,7 @@
     </request>
   </interface>
 
-  <interface name="zxdg_surface_v6" version="1">
+  <interface name="xdg_surface" version="2">
     <description summary="desktop user interface surface base interface">
       An interface that may be implemented by a wl_surface, for
       implementations that provide a desktop-style user interface.
@@ -388,11 +386,20 @@
       manipulate a buffer prior to the first xdg_surface.configure call must
       also be treated as errors.
 
-      For a surface to be mapped by the compositor, the following conditions
-      must be met: (1) the client has assigned a xdg_surface based role to the
-      surface, (2) the client has set and committed the xdg_surface state and
-      the role dependent state to the surface and (3) the client has committed a
-      buffer to the surface.
+      Mapping an xdg_surface-based role surface is defined as making it
+      possible for the surface to be shown by the compositor. Note that
+      a mapped surface is not guaranteed to be visible once it is mapped.
+
+      For an xdg_surface to be mapped by the compositor, the following
+      conditions must be met:
+      (1) the client has assigned an xdg_surface-based role to the surface
+      (2) the client has set and committed the xdg_surface state and the
+	  role-dependent state to the surface
+      (3) the client has committed a buffer to the surface
+
+      A newly-unmapped surface is considered to have met condition (1) out
+      of the 3 required conditions for mapping a surface if its role surface
+      has not been destroyed.
     </description>
 
     <enum name="error">
@@ -416,20 +423,23 @@
 	See the documentation of xdg_toplevel for more details about what an
 	xdg_toplevel is and how it is used.
       </description>
-      <arg name="id" type="new_id" interface="zxdg_toplevel_v6"/>
+      <arg name="id" type="new_id" interface="xdg_toplevel"/>
     </request>
 
     <request name="get_popup">
       <description summary="assign the xdg_popup surface role">
-	This creates an xdg_popup object for the given xdg_surface and gives the
-	associated wl_surface the xdg_popup role.
+	This creates an xdg_popup object for the given xdg_surface and gives
+	the associated wl_surface the xdg_popup role.
+
+	If null is passed as a parent, a parent surface must be specified using
+	some other protocol, before committing the initial state.
 
 	See the documentation of xdg_popup for more details about what an
 	xdg_popup is and how it is used.
       </description>
-      <arg name="id" type="new_id" interface="zxdg_popup_v6"/>
-      <arg name="parent" type="object" interface="zxdg_surface_v6"/>
-      <arg name="positioner" type="object" interface="zxdg_positioner_v6"/>
+      <arg name="id" type="new_id" interface="xdg_popup"/>
+      <arg name="parent" type="object" interface="xdg_surface" allow-null="true"/>
+      <arg name="positioner" type="object" interface="xdg_positioner"/>
     </request>
 
     <request name="set_window_geometry">
@@ -442,6 +452,11 @@
 	The window geometry is double buffered, and will be applied at the
 	time wl_surface.commit of the corresponding wl_surface is called.
 
+	When maintaining a position, the compositor should treat the (x, y)
+	coordinate of the window geometry as the top left corner of the window.
+	A client changing the (x, y) window geometry coordinate should in
+	general not alter the position of the window.
+
 	Once the window geometry of the surface is set, it is not possible to
 	unset it, and it will remain the same until set_window_geometry is
 	called again, even if a new subsurface or buffer is attached.
@@ -513,34 +528,50 @@
     </event>
   </interface>
 
-  <interface name="zxdg_toplevel_v6" version="1">
+  <interface name="xdg_toplevel" version="2">
     <description summary="toplevel surface">
       This interface defines an xdg_surface role which allows a surface to,
       among other things, set window-like properties such as maximize,
       fullscreen, and minimize, set application-specific metadata like title and
       id, and well as trigger user interactive operations such as interactive
       resize and move.
+
+      Unmapping an xdg_toplevel means that the surface cannot be shown
+      by the compositor until it is explicitly mapped again.
+      All active operations (e.g., move, resize) are canceled and all
+      attributes (e.g. title, state, stacking, ...) are discarded for
+      an xdg_toplevel surface when it is unmapped.
+
+      Attaching a null buffer to a toplevel unmaps the surface.
     </description>
 
     <request name="destroy" type="destructor">
       <description summary="destroy the xdg_toplevel">
-	Unmap and destroy the window. The window will be effectively
-	hidden from the user's point of view, and all state like
-	maximization, fullscreen, and so on, will be lost.
+	This request destroys the role surface and unmaps the surface;
+	see "Unmapping" behavior in interface section for details.
       </description>
     </request>
 
     <request name="set_parent">
       <description summary="set the parent of this surface">
-	Set the "parent" of this surface. This window should be stacked
-	above a parent. The parent surface must be mapped as long as this
-	surface is mapped.
+	Set the "parent" of this surface. This surface should be stacked
+	above the parent surface and all other ancestor surfaces.
 
 	Parent windows should be set on dialogs, toolboxes, or other
 	"auxiliary" surfaces, so that the parent is raised when the dialog
 	is raised.
+
+	Setting a null parent for a child window removes any parent-child
+	relationship for the child. Setting a null parent for a window which
+	currently has no parent is a no-op.
+
+	If the parent is unmapped then its children are managed as
+	though the parent of the now-unmapped parent has become the
+	parent of this surface. If no parent exists for the now-unmapped
+	parent then the children are managed as though they have no
+	parent surface.
       </description>
-      <arg name="parent" type="object" interface="zxdg_toplevel_v6" allow-null="true"/>
+      <arg name="parent" type="object" interface="xdg_toplevel" allow-null="true"/>
     </request>
 
     <request name="set_title">
@@ -573,6 +604,9 @@
 	For example, "org.freedesktop.FooViewer" where the .desktop file is
 	"org.freedesktop.FooViewer.desktop".
 
+	Like other properties, a set_app_id request can be sent after the
+	xdg_toplevel has been mapped to update the property.
+
 	See the desktop-entry specification [0] for more details on
 	application identifiers and how they relate to well-known D-Bus
 	names and .desktop files.
@@ -693,12 +727,18 @@
 	<description summary="the surface is maximized">
 	  The surface is maximized. The window geometry specified in the configure
 	  event must be obeyed by the client.
+
+	  The client should draw without shadow or other
+	  decoration outside of the window geometry.
 	</description>
       </entry>
       <entry name="fullscreen" value="2" summary="the surface is fullscreen">
 	<description summary="the surface is fullscreen">
-	  The surface is fullscreen. The window geometry specified in the configure
-	  event must be obeyed by the client.
+	  The surface is fullscreen. The window geometry specified in the
+	  configure event is a maximum; the client cannot resize beyond it. For
+	  a surface to cover the whole fullscreened area, the geometry
+	  dimensions must be obeyed by the client. For more details, see
+	  xdg_toplevel.set_fullscreen.
 	</description>
       </entry>
       <entry name="resizing" value="3" summary="the surface is being resized">
@@ -716,6 +756,30 @@
 	  keyboard or pointer focus.
 	</description>
       </entry>
+      <entry name="tiled_left" value="5" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the left edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
+      <entry name="tiled_right" value="6" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the right edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
+      <entry name="tiled_top" value="7" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the top edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
+      <entry name="tiled_bottom" value="8" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the bottom edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
     </enum>
 
     <request name="set_max_size">
@@ -805,12 +869,11 @@
 	Maximize the surface.
 
 	After requesting that the surface should be maximized, the compositor
-	will respond by emitting a configure event with the "maximized" state
-	and the required window geometry. The client should then update its
-	content, drawing it in a maximized state, i.e. without shadow or other
-	decoration outside of the window geometry. The client must also
-	acknowledge the configure when committing the new content (see
-	ack_configure).
+	will respond by emitting a configure event. Whether this configure
+	actually sets the window maximized is subject to compositor policies.
+	The client must then update its content, drawing in the configured
+	state. The client must also acknowledge the configure when committing
+	the new content (see ack_configure).
 
 	It is up to the compositor to decide how and where to maximize the
 	surface, for example which output and what region of the screen should
@@ -818,6 +881,10 @@
 
 	If the surface was already maximized, the compositor will still emit
 	a configure event with the "maximized" state.
+
+	If the surface is in a fullscreen state, this request has no direct
+	effect. It may alter the state the surface is returned to when
+	unmaximized unless overridden by the compositor.
       </description>
     </request>
 
@@ -826,13 +893,13 @@
 	Unmaximize the surface.
 
 	After requesting that the surface should be unmaximized, the compositor
-	will respond by emitting a configure event without the "maximized"
-	state. If available, the compositor will include the window geometry
-	dimensions the window had prior to being maximized in the configure
-	request. The client must then update its content, drawing it in a
-	regular state, i.e. potentially with shadow, etc. The client must also
-	acknowledge the configure when committing the new content (see
-	ack_configure).
+	will respond by emitting a configure event. Whether this actually
+	un-maximizes the window is subject to compositor policies.
+	If available and applicable, the compositor will include the window
+	geometry dimensions the window had prior to being maximized in the
+	configure event. The client must then update its content, drawing it in
+	the configured state. The client must also acknowledge the configure
+	when committing the new content (see ack_configure).
 
 	It is up to the compositor to position the surface after it was
 	unmaximized; usually the position the surface had before maximizing, if
@@ -840,24 +907,63 @@
 
 	If the surface was already not maximized, the compositor will still
 	emit a configure event without the "maximized" state.
+
+	If the surface is in a fullscreen state, this request has no direct
+	effect. It may alter the state the surface is returned to when
+	unmaximized unless overridden by the compositor.
       </description>
     </request>
 
     <request name="set_fullscreen">
-      <description summary="set the window as fullscreen on a monitor">
+      <description summary="set the window as fullscreen on an output">
 	Make the surface fullscreen.
 
-	You can specify an output that you would prefer to be fullscreen.
-	If this value is NULL, it's up to the compositor to choose which
-	display will be used to map this surface.
+	After requesting that the surface should be fullscreened, the
+	compositor will respond by emitting a configure event. Whether the
+	client is actually put into a fullscreen state is subject to compositor
+	policies. The client must also acknowledge the configure when
+	committing the new content (see ack_configure).
+
+	The output passed by the request indicates the client's preference as
+	to which display it should be set fullscreen on. If this value is NULL,
+	it's up to the compositor to choose which display will be used to map
+	this surface.
 
 	If the surface doesn't cover the whole output, the compositor will
 	position the surface in the center of the output and compensate with
-	black borders filling the rest of the output.
+	with border fill covering the rest of the output. The content of the
+	border fill is undefined, but should be assumed to be in some way that
+	attempts to blend into the surrounding area (e.g. solid black).
+
+	If the fullscreened surface is not opaque, the compositor must make
+	sure that other screen content not part of the same surface tree (made
+	up of subsurfaces, popups or similarly coupled surfaces) are not
+	visible below the fullscreened surface.
       </description>
       <arg name="output" type="object" interface="wl_output" allow-null="true"/>
     </request>
-    <request name="unset_fullscreen" />
+
+    <request name="unset_fullscreen">
+      <description summary="unset the window as fullscreen">
+	Make the surface no longer fullscreen.
+
+	After requesting that the surface should be unfullscreened, the
+	compositor will respond by emitting a configure event.
+	Whether this actually removes the fullscreen state of the client is
+	subject to compositor policies.
+
+	Making a surface unfullscreen sets states for the surface based on the following:
+	* the state(s) it may have had before becoming fullscreen
+	* any state(s) decided by the compositor
+	* any state(s) requested by the client while the surface was fullscreen
+
+	The compositor may include the previous window geometry dimensions in
+	the configure event, if applicable.
+
+	The client must also acknowledge the configure when committing the new
+	content (see ack_configure).
+      </description>
+    </request>
 
     <request name="set_minimized">
       <description summary="set the window as minimized">
@@ -913,7 +1019,7 @@
     </event>
   </interface>
 
-  <interface name="zxdg_popup_v6" version="1">
+  <interface name="xdg_popup" version="2">
     <description summary="short-lived, popup surfaces for menus">
       A popup surface is a short-lived, temporary surface. It can be used to
       implement for example menus, popovers, tooltips and other similar user
@@ -931,9 +1037,6 @@
       surface of their own is clicked should dismiss the popup using the destroy
       request.
 
-      The parent surface must have either the xdg_toplevel or xdg_popup surface
-      role.
-
       A newly created xdg_popup will be stacked on top of all previously created
       xdg_popup surfaces associated with the same xdg_toplevel.
 
diff --git a/vm_tools/sommelier/sommelier-xdg-shell.c b/vm_tools/sommelier/sommelier-xdg-shell.c
index ecd0fc647..a3ba0d6e1 100644
--- a/vm_tools/sommelier/sommelier-xdg-shell.c
+++ b/vm_tools/sommelier/sommelier-xdg-shell.c
@@ -7,37 +7,37 @@
 #include <assert.h>
 #include <stdlib.h>
 
-#include "xdg-shell-unstable-v6-client-protocol.h"
-#include "xdg-shell-unstable-v6-server-protocol.h"
+#include "xdg-shell-client-protocol.h"
+#include "xdg-shell-server-protocol.h"
 
-struct sl_host_xdg_shell {
+struct sl_host_xdg_wm_base {
   struct sl_context* ctx;
   struct wl_resource* resource;
-  struct zxdg_shell_v6* proxy;
+  struct xdg_wm_base* proxy;
 };
 
 struct sl_host_xdg_surface {
   struct sl_context* ctx;
   struct wl_resource* resource;
-  struct zxdg_surface_v6* proxy;
+  struct xdg_surface* proxy;
 };
 
 struct sl_host_xdg_toplevel {
   struct sl_context* ctx;
   struct wl_resource* resource;
-  struct zxdg_toplevel_v6* proxy;
+  struct xdg_toplevel* proxy;
 };
 
 struct sl_host_xdg_popup {
   struct sl_context* ctx;
   struct wl_resource* resource;
-  struct zxdg_popup_v6* proxy;
+  struct xdg_popup* proxy;
 };
 
 struct sl_host_xdg_positioner {
   struct sl_context* ctx;
   struct wl_resource* resource;
-  struct zxdg_positioner_v6* proxy;
+  struct xdg_positioner* proxy;
 };
 
 static void sl_xdg_positioner_destroy(struct wl_client* client,
@@ -52,7 +52,7 @@ static void sl_xdg_positioner_set_size(struct wl_client* client,
   struct sl_host_xdg_positioner* host = wl_resource_get_user_data(resource);
   double scale = host->ctx->scale;
 
-  zxdg_positioner_v6_set_size(host->proxy, width / scale, height / scale);
+  xdg_positioner_set_size(host->proxy, width / scale, height / scale);
 }
 
 static void sl_xdg_positioner_set_anchor_rect(struct wl_client* client,
@@ -70,7 +70,7 @@ static void sl_xdg_positioner_set_anchor_rect(struct wl_client* client,
   x2 = (x + width) / scale;
   y2 = (y + height) / scale;
 
-  zxdg_positioner_v6_set_anchor_rect(host->proxy, x1, y1, x2 - x1, y2 - y1);
+  xdg_positioner_set_anchor_rect(host->proxy, x1, y1, x2 - x1, y2 - y1);
 }
 
 static void sl_xdg_positioner_set_anchor(struct wl_client* client,
@@ -78,7 +78,7 @@ static void sl_xdg_positioner_set_anchor(struct wl_client* client,
                                          uint32_t anchor) {
   struct sl_host_xdg_positioner* host = wl_resource_get_user_data(resource);
 
-  zxdg_positioner_v6_set_anchor(host->proxy, anchor);
+  xdg_positioner_set_anchor(host->proxy, anchor);
 }
 
 static void sl_xdg_positioner_set_gravity(struct wl_client* client,
@@ -86,7 +86,7 @@ static void sl_xdg_positioner_set_gravity(struct wl_client* client,
                                           uint32_t gravity) {
   struct sl_host_xdg_positioner* host = wl_resource_get_user_data(resource);
 
-  zxdg_positioner_v6_set_gravity(host->proxy, gravity);
+  xdg_positioner_set_gravity(host->proxy, gravity);
 }
 
 static void sl_xdg_positioner_set_constraint_adjustment(
@@ -95,8 +95,8 @@ static void sl_xdg_positioner_set_constraint_adjustment(
     uint32_t constraint_adjustment) {
   struct sl_host_xdg_positioner* host = wl_resource_get_user_data(resource);
 
-  zxdg_positioner_v6_set_constraint_adjustment(host->proxy,
-                                               constraint_adjustment);
+  xdg_positioner_set_constraint_adjustment(host->proxy,
+                                           constraint_adjustment);
 }
 
 static void sl_xdg_positioner_set_offset(struct wl_client* client,
@@ -106,10 +106,10 @@ static void sl_xdg_positioner_set_offset(struct wl_client* client,
   struct sl_host_xdg_positioner* host = wl_resource_get_user_data(resource);
   double scale = host->ctx->scale;
 
-  zxdg_positioner_v6_set_offset(host->proxy, x / scale, y / scale);
+  xdg_positioner_set_offset(host->proxy, x / scale, y / scale);
 }
 
-static const struct zxdg_positioner_v6_interface
+static const struct xdg_positioner_interface
     sl_xdg_positioner_implementation = {
         sl_xdg_positioner_destroy,
         sl_xdg_positioner_set_size,
@@ -122,7 +122,7 @@ static const struct zxdg_positioner_v6_interface
 static void sl_destroy_host_xdg_positioner(struct wl_resource* resource) {
   struct sl_host_xdg_positioner* host = wl_resource_get_user_data(resource);
 
-  zxdg_positioner_v6_destroy(host->proxy);
+  xdg_positioner_destroy(host->proxy);
   wl_resource_set_user_data(resource, NULL);
   free(host);
 }
@@ -139,19 +139,19 @@ static void sl_xdg_popup_grab(struct wl_client* client,
   struct sl_host_xdg_popup* host = wl_resource_get_user_data(resource);
   struct sl_host_seat* host_seat = wl_resource_get_user_data(seat_resource);
 
-  zxdg_popup_v6_grab(host->proxy, host_seat->proxy, serial);
+  xdg_popup_grab(host->proxy, host_seat->proxy, serial);
 }
 
-static const struct zxdg_popup_v6_interface sl_xdg_popup_implementation = {
+static const struct xdg_popup_interface sl_xdg_popup_implementation = {
     sl_xdg_popup_destroy, sl_xdg_popup_grab};
 
 static void sl_xdg_popup_configure(void* data,
-                                   struct zxdg_popup_v6* xdg_popup,
+                                   struct xdg_popup* xdg_popup,
                                    int32_t x,
                                    int32_t y,
                                    int32_t width,
                                    int32_t height) {
-  struct sl_host_xdg_popup* host = zxdg_popup_v6_get_user_data(xdg_popup);
+  struct sl_host_xdg_popup* host = xdg_popup_get_user_data(xdg_popup);
   double scale = host->ctx->scale;
   int32_t x1, y1, x2, y2;
 
@@ -160,23 +160,23 @@ static void sl_xdg_popup_configure(void* data,
   x2 = (x + width) * scale;
   y2 = (y + height) * scale;
 
-  zxdg_popup_v6_send_configure(host->resource, x1, y1, x2 - x1, y2 - y1);
+  xdg_popup_send_configure(host->resource, x1, y1, x2 - x1, y2 - y1);
 }
 
 static void sl_xdg_popup_popup_done(void* data,
-                                    struct zxdg_popup_v6* xdg_popup) {
-  struct sl_host_xdg_popup* host = zxdg_popup_v6_get_user_data(xdg_popup);
+                                    struct xdg_popup* xdg_popup) {
+  struct sl_host_xdg_popup* host = xdg_popup_get_user_data(xdg_popup);
 
-  zxdg_popup_v6_send_popup_done(host->resource);
+  xdg_popup_send_popup_done(host->resource);
 }
 
-static const struct zxdg_popup_v6_listener sl_xdg_popup_listener = {
+static const struct xdg_popup_listener sl_xdg_popup_listener = {
     sl_xdg_popup_configure, sl_xdg_popup_popup_done};
 
 static void sl_destroy_host_xdg_popup(struct wl_resource* resource) {
   struct sl_host_xdg_popup* host = wl_resource_get_user_data(resource);
 
-  zxdg_popup_v6_destroy(host->proxy);
+  xdg_popup_destroy(host->proxy);
   wl_resource_set_user_data(resource, NULL);
   free(host);
 }
@@ -193,8 +193,8 @@ static void sl_xdg_toplevel_set_parent(struct wl_client* client,
   struct sl_host_xdg_toplevel* host_parent =
       parent_resource ? wl_resource_get_user_data(parent_resource) : NULL;
 
-  zxdg_toplevel_v6_set_parent(host->proxy,
-                              host_parent ? host_parent->proxy : NULL);
+  xdg_toplevel_set_parent(host->proxy,
+                          host_parent ? host_parent->proxy : NULL);
 }
 
 static void sl_xdg_toplevel_set_title(struct wl_client* client,
@@ -202,7 +202,7 @@ static void sl_xdg_toplevel_set_title(struct wl_client* client,
                                       const char* title) {
   struct sl_host_xdg_toplevel* host = wl_resource_get_user_data(resource);
 
-  zxdg_toplevel_v6_set_title(host->proxy, title);
+  xdg_toplevel_set_title(host->proxy, title);
 }
 
 static void sl_xdg_toplevel_set_app_id(struct wl_client* client,
@@ -210,7 +210,7 @@ static void sl_xdg_toplevel_set_app_id(struct wl_client* client,
                                        const char* app_id) {
   struct sl_host_xdg_toplevel* host = wl_resource_get_user_data(resource);
 
-  zxdg_toplevel_v6_set_app_id(host->proxy, app_id);
+  xdg_toplevel_set_app_id(host->proxy, app_id);
 }
 
 static void sl_xdg_toplevel_show_window_menu(struct wl_client* client,
@@ -223,7 +223,7 @@ static void sl_xdg_toplevel_show_window_menu(struct wl_client* client,
   struct sl_host_seat* host_seat =
       seat_resource ? wl_resource_get_user_data(seat_resource) : NULL;
 
-  zxdg_toplevel_v6_show_window_menu(
+  xdg_toplevel_show_window_menu(
       host->proxy, host_seat ? host_seat->proxy : NULL, serial, x, y);
 }
 
@@ -235,8 +235,8 @@ static void sl_xdg_toplevel_move(struct wl_client* client,
   struct sl_host_seat* host_seat =
       seat_resource ? wl_resource_get_user_data(seat_resource) : NULL;
 
-  zxdg_toplevel_v6_move(host->proxy, host_seat ? host_seat->proxy : NULL,
-                        serial);
+  xdg_toplevel_move(host->proxy, host_seat ? host_seat->proxy : NULL,
+                    serial);
 }
 
 static void sl_xdg_toplevel_resize(struct wl_client* client,
@@ -248,8 +248,8 @@ static void sl_xdg_toplevel_resize(struct wl_client* client,
   struct sl_host_seat* host_seat =
       seat_resource ? wl_resource_get_user_data(seat_resource) : NULL;
 
-  zxdg_toplevel_v6_resize(host->proxy, host_seat ? host_seat->proxy : NULL,
-                          serial, edges);
+  xdg_toplevel_resize(host->proxy, host_seat ? host_seat->proxy : NULL,
+                      serial, edges);
 }
 
 static void sl_xdg_toplevel_set_max_size(struct wl_client* client,
@@ -258,7 +258,7 @@ static void sl_xdg_toplevel_set_max_size(struct wl_client* client,
                                          int32_t height) {
   struct sl_host_xdg_toplevel* host = wl_resource_get_user_data(resource);
 
-  zxdg_toplevel_v6_set_max_size(host->proxy, width, height);
+  xdg_toplevel_set_max_size(host->proxy, width, height);
 }
 
 static void sl_xdg_toplevel_set_min_size(struct wl_client* client,
@@ -267,21 +267,21 @@ static void sl_xdg_toplevel_set_min_size(struct wl_client* client,
                                          int32_t height) {
   struct sl_host_xdg_toplevel* host = wl_resource_get_user_data(resource);
 
-  zxdg_toplevel_v6_set_min_size(host->proxy, width, height);
+  xdg_toplevel_set_min_size(host->proxy, width, height);
 }
 
 static void sl_xdg_toplevel_set_maximized(struct wl_client* client,
                                           struct wl_resource* resource) {
   struct sl_host_xdg_toplevel* host = wl_resource_get_user_data(resource);
 
-  zxdg_toplevel_v6_set_maximized(host->proxy);
+  xdg_toplevel_set_maximized(host->proxy);
 }
 
 static void sl_xdg_toplevel_unset_maximized(struct wl_client* client,
                                             struct wl_resource* resource) {
   struct sl_host_xdg_toplevel* host = wl_resource_get_user_data(resource);
 
-  zxdg_toplevel_v6_unset_maximized(host->proxy);
+  xdg_toplevel_unset_maximized(host->proxy);
 }
 
 static void sl_xdg_toplevel_set_fullscreen(
@@ -292,25 +292,25 @@ static void sl_xdg_toplevel_set_fullscreen(
   struct sl_host_output* host_output =
       output_resource ? wl_resource_get_user_data(output_resource) : NULL;
 
-  zxdg_toplevel_v6_set_fullscreen(host->proxy,
-                                  host_output ? host_output->proxy : NULL);
+  xdg_toplevel_set_fullscreen(host->proxy,
+                              host_output ? host_output->proxy : NULL);
 }
 
 static void sl_xdg_toplevel_unset_fullscreen(struct wl_client* client,
                                              struct wl_resource* resource) {
   struct sl_host_xdg_toplevel* host = wl_resource_get_user_data(resource);
 
-  zxdg_toplevel_v6_unset_fullscreen(host->proxy);
+  xdg_toplevel_unset_fullscreen(host->proxy);
 }
 
 static void sl_xdg_toplevel_set_minimized(struct wl_client* client,
                                           struct wl_resource* resource) {
   struct sl_host_xdg_toplevel* host = wl_resource_get_user_data(resource);
 
-  zxdg_toplevel_v6_set_minimized(host->proxy);
+  xdg_toplevel_set_minimized(host->proxy);
 }
 
-static const struct zxdg_toplevel_v6_interface sl_xdg_toplevel_implementation =
+static const struct xdg_toplevel_interface sl_xdg_toplevel_implementation =
     {sl_xdg_toplevel_destroy,          sl_xdg_toplevel_set_parent,
      sl_xdg_toplevel_set_title,        sl_xdg_toplevel_set_app_id,
      sl_xdg_toplevel_show_window_menu, sl_xdg_toplevel_move,
@@ -320,33 +320,33 @@ static const struct zxdg_toplevel_v6_interface sl_xdg_toplevel_implementation =
      sl_xdg_toplevel_unset_fullscreen, sl_xdg_toplevel_set_minimized};
 
 static void sl_xdg_toplevel_configure(void* data,
-                                      struct zxdg_toplevel_v6* xdg_toplevel,
+                                      struct xdg_toplevel* xdg_toplevel,
                                       int32_t width,
                                       int32_t height,
                                       struct wl_array* states) {
   struct sl_host_xdg_toplevel* host =
-      zxdg_toplevel_v6_get_user_data(xdg_toplevel);
+      xdg_toplevel_get_user_data(xdg_toplevel);
   double scale = host->ctx->scale;
 
-  zxdg_toplevel_v6_send_configure(host->resource, width * scale, height * scale,
+  xdg_toplevel_send_configure(host->resource, width * scale, height * scale,
                                   states);
 }
 
 static void sl_xdg_toplevel_close(void* data,
-                                  struct zxdg_toplevel_v6* xdg_toplevel) {
+                                  struct xdg_toplevel* xdg_toplevel) {
   struct sl_host_xdg_toplevel* host =
-      zxdg_toplevel_v6_get_user_data(xdg_toplevel);
+      xdg_toplevel_get_user_data(xdg_toplevel);
 
-  zxdg_toplevel_v6_send_close(host->resource);
+  xdg_toplevel_send_close(host->resource);
 }
 
-static const struct zxdg_toplevel_v6_listener sl_xdg_toplevel_listener = {
+static const struct xdg_toplevel_listener sl_xdg_toplevel_listener = {
     sl_xdg_toplevel_configure, sl_xdg_toplevel_close};
 
 static void sl_destroy_host_xdg_toplevel(struct wl_resource* resource) {
   struct sl_host_xdg_toplevel* host = wl_resource_get_user_data(resource);
 
-  zxdg_toplevel_v6_destroy(host->proxy);
+  xdg_toplevel_destroy(host->proxy);
   wl_resource_set_user_data(resource, NULL);
   free(host);
 }
@@ -367,14 +367,15 @@ static void sl_xdg_surface_get_toplevel(struct wl_client* client,
 
   host_xdg_toplevel->ctx = host->ctx;
   host_xdg_toplevel->resource =
-      wl_resource_create(client, &zxdg_toplevel_v6_interface, 1, id);
+      wl_resource_create(client, &xdg_toplevel_interface,
+                         wl_resource_get_version(resource), id);
   wl_resource_set_implementation(
       host_xdg_toplevel->resource, &sl_xdg_toplevel_implementation,
       host_xdg_toplevel, sl_destroy_host_xdg_toplevel);
-  host_xdg_toplevel->proxy = zxdg_surface_v6_get_toplevel(host->proxy);
-  zxdg_toplevel_v6_set_user_data(host_xdg_toplevel->proxy, host_xdg_toplevel);
-  zxdg_toplevel_v6_add_listener(host_xdg_toplevel->proxy,
-                                &sl_xdg_toplevel_listener, host_xdg_toplevel);
+  host_xdg_toplevel->proxy = xdg_surface_get_toplevel(host->proxy);
+  xdg_toplevel_set_user_data(host_xdg_toplevel->proxy, host_xdg_toplevel);
+  xdg_toplevel_add_listener(host_xdg_toplevel->proxy,
+                            &sl_xdg_toplevel_listener, host_xdg_toplevel);
 }
 
 static void sl_xdg_surface_get_popup(struct wl_client* client,
@@ -394,15 +395,16 @@ static void sl_xdg_surface_get_popup(struct wl_client* client,
 
   host_xdg_popup->ctx = host->ctx;
   host_xdg_popup->resource =
-      wl_resource_create(client, &zxdg_popup_v6_interface, 1, id);
+      wl_resource_create(client, &xdg_popup_interface,
+                         wl_resource_get_version(resource), id);
   wl_resource_set_implementation(host_xdg_popup->resource,
                                  &sl_xdg_popup_implementation, host_xdg_popup,
                                  sl_destroy_host_xdg_popup);
-  host_xdg_popup->proxy = zxdg_surface_v6_get_popup(
+  host_xdg_popup->proxy = xdg_surface_get_popup(
       host->proxy, host_parent->proxy, host_positioner->proxy);
-  zxdg_popup_v6_set_user_data(host_xdg_popup->proxy, host_xdg_popup);
-  zxdg_popup_v6_add_listener(host_xdg_popup->proxy, &sl_xdg_popup_listener,
-                             host_xdg_popup);
+  xdg_popup_set_user_data(host_xdg_popup->proxy, host_xdg_popup);
+  xdg_popup_add_listener(host_xdg_popup->proxy, &sl_xdg_popup_listener,
+                         host_xdg_popup);
 }
 
 static void sl_xdg_surface_set_window_geometry(struct wl_client* client,
@@ -420,7 +422,7 @@ static void sl_xdg_surface_set_window_geometry(struct wl_client* client,
   x2 = (x + width) / scale;
   y2 = (y + height) / scale;
 
-  zxdg_surface_v6_set_window_geometry(host->proxy, x1, y1, x2 - x1, y2 - y1);
+  xdg_surface_set_window_geometry(host->proxy, x1, y1, x2 - x1, y2 - y1);
 }
 
 static void sl_xdg_surface_ack_configure(struct wl_client* client,
@@ -428,63 +430,64 @@ static void sl_xdg_surface_ack_configure(struct wl_client* client,
                                          uint32_t serial) {
   struct sl_host_xdg_surface* host = wl_resource_get_user_data(resource);
 
-  zxdg_surface_v6_ack_configure(host->proxy, serial);
+  xdg_surface_ack_configure(host->proxy, serial);
 }
 
-static const struct zxdg_surface_v6_interface sl_xdg_surface_implementation = {
+static const struct xdg_surface_interface sl_xdg_surface_implementation = {
     sl_xdg_surface_destroy, sl_xdg_surface_get_toplevel,
     sl_xdg_surface_get_popup, sl_xdg_surface_set_window_geometry,
     sl_xdg_surface_ack_configure};
 
 static void sl_xdg_surface_configure(void* data,
-                                     struct zxdg_surface_v6* xdg_surface,
+                                     struct xdg_surface* xdg_surface,
                                      uint32_t serial) {
-  struct sl_host_xdg_surface* host = zxdg_surface_v6_get_user_data(xdg_surface);
+  struct sl_host_xdg_surface* host = xdg_surface_get_user_data(xdg_surface);
 
-  zxdg_surface_v6_send_configure(host->resource, serial);
+  xdg_surface_send_configure(host->resource, serial);
 }
 
-static const struct zxdg_surface_v6_listener sl_xdg_surface_listener = {
+static const struct xdg_surface_listener sl_xdg_surface_listener = {
     sl_xdg_surface_configure};
 
 static void sl_destroy_host_xdg_surface(struct wl_resource* resource) {
   struct sl_host_xdg_surface* host = wl_resource_get_user_data(resource);
 
-  zxdg_surface_v6_destroy(host->proxy);
+  xdg_surface_destroy(host->proxy);
   wl_resource_set_user_data(resource, NULL);
   free(host);
 }
 
-static void sl_xdg_shell_destroy(struct wl_client* client,
+static void sl_xdg_wm_base_destroy(struct wl_client* client,
                                  struct wl_resource* resource) {
   wl_resource_destroy(resource);
 }
 
-static void sl_xdg_shell_create_positioner(struct wl_client* client,
+static void sl_xdg_wm_base_create_positioner(struct wl_client* client,
                                            struct wl_resource* resource,
                                            uint32_t id) {
-  struct sl_host_xdg_shell* host = wl_resource_get_user_data(resource);
+  struct sl_host_xdg_wm_base* host = wl_resource_get_user_data(resource);
   struct sl_host_xdg_positioner* host_xdg_positioner;
 
   host_xdg_positioner = malloc(sizeof(*host_xdg_positioner));
   assert(host_xdg_positioner);
 
   host_xdg_positioner->ctx = host->ctx;
-  host_xdg_positioner->resource =
-      wl_resource_create(client, &zxdg_positioner_v6_interface, 1, id);
+  host_xdg_positioner->resource = wl_resource_create(
+      client, &xdg_positioner_interface,
+      wl_resource_get_version(resource), id);
   wl_resource_set_implementation(
       host_xdg_positioner->resource, &sl_xdg_positioner_implementation,
       host_xdg_positioner, sl_destroy_host_xdg_positioner);
-  host_xdg_positioner->proxy = zxdg_shell_v6_create_positioner(host->proxy);
-  zxdg_positioner_v6_set_user_data(host_xdg_positioner->proxy,
-                                   host_xdg_positioner);
+  host_xdg_positioner->proxy = xdg_wm_base_create_positioner(host->proxy);
+  xdg_positioner_set_user_data(host_xdg_positioner->proxy,
+                               host_xdg_positioner);
 }
 
-static void sl_xdg_shell_get_xdg_surface(struct wl_client* client,
+static void sl_xdg_wm_base_get_xdg_surface(struct wl_client* client,
                                          struct wl_resource* resource,
                                          uint32_t id,
                                          struct wl_resource* surface_resource) {
-  struct sl_host_xdg_shell* host = wl_resource_get_user_data(resource);
+  struct sl_host_xdg_wm_base* host = wl_resource_get_user_data(resource);
   struct sl_host_surface* host_surface =
       wl_resource_get_user_data(surface_resource);
   struct sl_host_xdg_surface* host_xdg_surface;
@@ -493,71 +496,75 @@ static void sl_xdg_shell_get_xdg_surface(struct wl_client* client,
   assert(host_xdg_surface);
 
   host_xdg_surface->ctx = host->ctx;
-  host_xdg_surface->resource =
-      wl_resource_create(client, &zxdg_surface_v6_interface, 1, id);
+  host_xdg_surface->resource = wl_resource_create(
+      client, &xdg_surface_interface,
+      wl_resource_get_version(resource), id);
   wl_resource_set_implementation(host_xdg_surface->resource,
                                  &sl_xdg_surface_implementation,
                                  host_xdg_surface, sl_destroy_host_xdg_surface);
   host_xdg_surface->proxy =
-      zxdg_shell_v6_get_xdg_surface(host->proxy, host_surface->proxy);
-  zxdg_surface_v6_set_user_data(host_xdg_surface->proxy, host_xdg_surface);
-  zxdg_surface_v6_add_listener(host_xdg_surface->proxy,
-                               &sl_xdg_surface_listener, host_xdg_surface);
+      xdg_wm_base_get_xdg_surface(host->proxy, host_surface->proxy);
+  xdg_surface_set_user_data(host_xdg_surface->proxy, host_xdg_surface);
+  xdg_surface_add_listener(host_xdg_surface->proxy,
+                           &sl_xdg_surface_listener, host_xdg_surface);
   host_surface->has_role = 1;
 }
 
-static void sl_xdg_shell_pong(struct wl_client* client,
+static void sl_xdg_wm_base_pong(struct wl_client* client,
                               struct wl_resource* resource,
                               uint32_t serial) {
-  struct sl_host_xdg_shell* host = wl_resource_get_user_data(resource);
+  struct sl_host_xdg_wm_base* host = wl_resource_get_user_data(resource);
 
-  zxdg_shell_v6_pong(host->proxy, serial);
+  xdg_wm_base_pong(host->proxy, serial);
 }
 
-static const struct zxdg_shell_v6_interface sl_xdg_shell_implementation = {
-    sl_xdg_shell_destroy, sl_xdg_shell_create_positioner,
-    sl_xdg_shell_get_xdg_surface, sl_xdg_shell_pong};
+static const struct xdg_wm_base_interface sl_xdg_wm_base_implementation = {
+    sl_xdg_wm_base_destroy, sl_xdg_wm_base_create_positioner,
+    sl_xdg_wm_base_get_xdg_surface, sl_xdg_wm_base_pong};
 
-static void sl_xdg_shell_ping(void* data,
-                              struct zxdg_shell_v6* xdg_shell,
+static void sl_xdg_wm_base_ping(void* data,
+                              struct xdg_wm_base* xdg_wm_base,
                               uint32_t serial) {
-  struct sl_host_xdg_shell* host = zxdg_shell_v6_get_user_data(xdg_shell);
+  struct sl_host_xdg_wm_base* host = xdg_wm_base_get_user_data(xdg_wm_base);
 
-  zxdg_shell_v6_send_ping(host->resource, serial);
+  xdg_wm_base_send_ping(host->resource, serial);
 }
 
-static const struct zxdg_shell_v6_listener sl_xdg_shell_listener = {
-    sl_xdg_shell_ping};
+static const struct xdg_wm_base_listener sl_xdg_wm_base_listener = {
+    sl_xdg_wm_base_ping};
 
-static void sl_destroy_host_xdg_shell(struct wl_resource* resource) {
-  struct sl_host_xdg_shell* host = wl_resource_get_user_data(resource);
+static void sl_destroy_host_xdg_wm_base(struct wl_resource* resource) {
+  struct sl_host_xdg_wm_base* host = wl_resource_get_user_data(resource);
 
-  zxdg_shell_v6_destroy(host->proxy);
+  xdg_wm_base_destroy(host->proxy);
   wl_resource_set_user_data(resource, NULL);
   free(host);
 }
 
-static void sl_bind_host_xdg_shell(struct wl_client* client,
+static void sl_bind_host_xdg_wm_base(struct wl_client* client,
                                    void* data,
                                    uint32_t version,
                                    uint32_t id) {
   struct sl_context* ctx = (struct sl_context*)data;
-  struct sl_host_xdg_shell* host;
+  struct sl_host_xdg_wm_base* host;
 
   host = malloc(sizeof(*host));
   assert(host);
   host->ctx = ctx;
-  host->resource = wl_resource_create(client, &zxdg_shell_v6_interface, 1, id);
-  wl_resource_set_implementation(host->resource, &sl_xdg_shell_implementation,
-                                 host, sl_destroy_host_xdg_shell);
+  host->resource = wl_resource_create(client, &xdg_wm_base_interface,
+				      ctx->xdg_wm_base->id, id);
+  wl_resource_set_implementation(host->resource, &sl_xdg_wm_base_implementation,
+                                 host, sl_destroy_host_xdg_wm_base);
   host->proxy =
       wl_registry_bind(wl_display_get_registry(ctx->display),
-                       ctx->xdg_shell->id, &zxdg_shell_v6_interface, 1);
-  zxdg_shell_v6_set_user_data(host->proxy, host);
-  zxdg_shell_v6_add_listener(host->proxy, &sl_xdg_shell_listener, host);
+                       ctx->xdg_wm_base->id, &xdg_wm_base_interface,
+                       ctx->xdg_wm_base->version);
+  xdg_wm_base_set_user_data(host->proxy, host);
+  xdg_wm_base_add_listener(host->proxy, &sl_xdg_wm_base_listener, host);
 }
 
-struct sl_global* sl_xdg_shell_global_create(struct sl_context* ctx) {
-  return sl_global_create(ctx, &zxdg_shell_v6_interface, 1, ctx,
-                          sl_bind_host_xdg_shell);
+struct sl_global* sl_xdg_wm_base_global_create(struct sl_context* ctx) {
+  return sl_global_create(ctx, &xdg_wm_base_interface,
+                          ctx->xdg_wm_base->version, ctx,
+                          sl_bind_host_xdg_wm_base);
 }
diff --git a/vm_tools/sommelier/sommelier.c b/vm_tools/sommelier/sommelier.c
index e58e6ee8d..06c45acda 100644
--- a/vm_tools/sommelier/sommelier.c
+++ b/vm_tools/sommelier/sommelier.c
@@ -35,7 +35,7 @@
 #include "relative-pointer-unstable-v1-client-protocol.h"
 #include "text-input-unstable-v1-client-protocol.h"
 #include "viewporter-client-protocol.h"
-#include "xdg-shell-unstable-v6-client-protocol.h"
+#include "xdg-shell-client-protocol.h"
 
 #define errno_assert(rv)                                          \
   {                                                               \
@@ -283,14 +283,14 @@ void sl_sync_point_destroy(struct sl_sync_point* sync_point) {
   free(sync_point);
 }
 
-static void sl_internal_xdg_shell_ping(void* data,
-                                       struct zxdg_shell_v6* xdg_shell,
+static void sl_internal_xdg_wm_base_ping(void* data,
+                                       struct xdg_wm_base* xdg_wm_base,
                                        uint32_t serial) {
-  zxdg_shell_v6_pong(xdg_shell, serial);
+  xdg_wm_base_pong(xdg_wm_base, serial);
 }
 
-static const struct zxdg_shell_v6_listener sl_internal_xdg_shell_listener = {
-    sl_internal_xdg_shell_ping};
+static const struct xdg_wm_base_listener sl_internal_xdg_wm_base_listener = {
+    sl_internal_xdg_wm_base_ping};
 
 static void sl_send_configure_notify(struct sl_window* window) {
   xcb_configure_notify_event_t event = {
@@ -455,8 +455,8 @@ int sl_process_pending_configure_acks(struct sl_window* window,
   }
 
   if (window->xdg_surface) {
-    zxdg_surface_v6_ack_configure(window->xdg_surface,
-                                  window->pending_config.serial);
+    xdg_surface_ack_configure(window->xdg_surface,
+                              window->pending_config.serial);
   }
   window->pending_config.serial = 0;
 
@@ -467,8 +467,8 @@ int sl_process_pending_configure_acks(struct sl_window* window,
 }
 
 static void sl_internal_xdg_surface_configure(
-    void* data, struct zxdg_surface_v6* xdg_surface, uint32_t serial) {
-  struct sl_window* window = zxdg_surface_v6_get_user_data(xdg_surface);
+    void* data, struct xdg_surface* xdg_surface, uint32_t serial) {
+  struct sl_window* window = xdg_surface_get_user_data(xdg_surface);
 
   window->next_config.serial = serial;
   if (!window->pending_config.serial) {
@@ -489,16 +489,16 @@ static void sl_internal_xdg_surface_configure(
   }
 }
 
-static const struct zxdg_surface_v6_listener sl_internal_xdg_surface_listener =
+static const struct xdg_surface_listener sl_internal_xdg_surface_listener =
     {sl_internal_xdg_surface_configure};
 
 static void sl_internal_xdg_toplevel_configure(
     void* data,
-    struct zxdg_toplevel_v6* xdg_toplevel,
+    struct xdg_toplevel* xdg_toplevel,
     int32_t width,
     int32_t height,
     struct wl_array* states) {
-  struct sl_window* window = zxdg_toplevel_v6_get_user_data(xdg_toplevel);
+  struct sl_window* window = xdg_toplevel_get_user_data(xdg_toplevel);
   int activated = 0;
   uint32_t* state;
   int i = 0;
@@ -528,21 +528,21 @@ static void sl_internal_xdg_toplevel_configure(
 
   window->allow_resize = 1;
   wl_array_for_each(state, states) {
-    if (*state == ZXDG_TOPLEVEL_V6_STATE_FULLSCREEN) {
+    if (*state == XDG_TOPLEVEL_STATE_FULLSCREEN) {
       window->allow_resize = 0;
       window->next_config.states[i++] =
           window->ctx->atoms[ATOM_NET_WM_STATE_FULLSCREEN].value;
     }
-    if (*state == ZXDG_TOPLEVEL_V6_STATE_MAXIMIZED) {
+    if (*state == XDG_TOPLEVEL_STATE_MAXIMIZED) {
       window->allow_resize = 0;
       window->next_config.states[i++] =
           window->ctx->atoms[ATOM_NET_WM_STATE_MAXIMIZED_VERT].value;
       window->next_config.states[i++] =
           window->ctx->atoms[ATOM_NET_WM_STATE_MAXIMIZED_HORZ].value;
     }
-    if (*state == ZXDG_TOPLEVEL_V6_STATE_ACTIVATED)
+    if (*state == XDG_TOPLEVEL_STATE_ACTIVATED)
       activated = 1;
-    if (*state == ZXDG_TOPLEVEL_V6_STATE_RESIZING)
+    if (*state == XDG_TOPLEVEL_STATE_RESIZING)
       window->allow_resize = 0;
   }
 
@@ -558,8 +558,8 @@ static void sl_internal_xdg_toplevel_configure(
 }
 
 static void sl_internal_xdg_toplevel_close(
-    void* data, struct zxdg_toplevel_v6* xdg_toplevel) {
-  struct sl_window* window = zxdg_toplevel_v6_get_user_data(xdg_toplevel);
+    void* data, struct xdg_toplevel* xdg_toplevel) {
+  struct sl_window* window = xdg_toplevel_get_user_data(xdg_toplevel);
   xcb_client_message_event_t event = {
       .response_type = XCB_CLIENT_MESSAGE,
       .format = 32,
@@ -576,21 +576,21 @@ static void sl_internal_xdg_toplevel_close(
                  XCB_EVENT_MASK_NO_EVENT, (const char*)&event);
 }
 
-static const struct zxdg_toplevel_v6_listener
+static const struct xdg_toplevel_listener
     sl_internal_xdg_toplevel_listener = {sl_internal_xdg_toplevel_configure,
                                          sl_internal_xdg_toplevel_close};
 
 static void sl_internal_xdg_popup_configure(void* data,
-                                            struct zxdg_popup_v6* xdg_popup,
+                                            struct xdg_popup* xdg_popup,
                                             int32_t x,
                                             int32_t y,
                                             int32_t width,
                                             int32_t height) {}
 
 static void sl_internal_xdg_popup_done(void* data,
-                                       struct zxdg_popup_v6* zxdg_popup_v6) {}
+                                       struct xdg_popup* xdg_popup) {}
 
-static const struct zxdg_popup_v6_listener sl_internal_xdg_popup_listener = {
+static const struct xdg_popup_listener sl_internal_xdg_popup_listener = {
     sl_internal_xdg_popup_configure, sl_internal_xdg_popup_done};
 
 static void sl_window_set_wm_state(struct sl_window* window, int state) {
@@ -658,15 +658,15 @@ void sl_window_update(struct sl_window* window) {
       window->aura_surface = NULL;
     }
     if (window->xdg_toplevel) {
-      zxdg_toplevel_v6_destroy(window->xdg_toplevel);
+      xdg_toplevel_destroy(window->xdg_toplevel);
       window->xdg_toplevel = NULL;
     }
     if (window->xdg_popup) {
-      zxdg_popup_v6_destroy(window->xdg_popup);
+      xdg_popup_destroy(window->xdg_popup);
       window->xdg_popup = NULL;
     }
     if (window->xdg_surface) {
-      zxdg_surface_v6_destroy(window->xdg_surface);
+      xdg_surface_destroy(window->xdg_surface);
       window->xdg_surface = NULL;
     }
     window->realized = 0;
@@ -677,8 +677,8 @@ void sl_window_update(struct sl_window* window) {
   assert(host_surface);
   assert(!host_surface->has_role);
 
-  assert(ctx->xdg_shell);
-  assert(ctx->xdg_shell->internal);
+  assert(ctx->xdg_wm_base);
+  assert(ctx->xdg_wm_base->internal);
 
   if (window->managed) {
     if (window->transient_for != XCB_WINDOW_NONE) {
@@ -740,11 +740,11 @@ void sl_window_update(struct sl_window* window) {
   }
 
   if (!window->xdg_surface) {
-    window->xdg_surface = zxdg_shell_v6_get_xdg_surface(
-        ctx->xdg_shell->internal, host_surface->proxy);
-    zxdg_surface_v6_set_user_data(window->xdg_surface, window);
-    zxdg_surface_v6_add_listener(window->xdg_surface,
-                                 &sl_internal_xdg_surface_listener, window);
+    window->xdg_surface = xdg_wm_base_get_xdg_surface(
+        ctx->xdg_wm_base->internal, host_surface->proxy);
+    xdg_surface_set_user_data(window->xdg_surface, window);
+    xdg_surface_add_listener(window->xdg_surface,
+                             &sl_internal_xdg_surface_listener, window);
   }
 
   if (ctx->aura_shell) {
@@ -778,50 +778,50 @@ void sl_window_update(struct sl_window* window) {
   // window is closed.
   if (ctx->xwayland || !parent) {
     if (!window->xdg_toplevel) {
-      window->xdg_toplevel = zxdg_surface_v6_get_toplevel(window->xdg_surface);
-      zxdg_toplevel_v6_set_user_data(window->xdg_toplevel, window);
-      zxdg_toplevel_v6_add_listener(window->xdg_toplevel,
+      window->xdg_toplevel = xdg_surface_get_toplevel(window->xdg_surface);
+      xdg_toplevel_set_user_data(window->xdg_toplevel, window);
+      xdg_toplevel_add_listener(window->xdg_toplevel,
                                     &sl_internal_xdg_toplevel_listener, window);
     }
     if (parent)
-      zxdg_toplevel_v6_set_parent(window->xdg_toplevel, parent->xdg_toplevel);
+      xdg_toplevel_set_parent(window->xdg_toplevel, parent->xdg_toplevel);
     if (window->name)
-      zxdg_toplevel_v6_set_title(window->xdg_toplevel, window->name);
+      xdg_toplevel_set_title(window->xdg_toplevel, window->name);
     if (window->size_flags & P_MIN_SIZE) {
-      zxdg_toplevel_v6_set_min_size(window->xdg_toplevel,
+      xdg_toplevel_set_min_size(window->xdg_toplevel,
                                     window->min_width / ctx->scale,
                                     window->min_height / ctx->scale);
     }
     if (window->size_flags & P_MAX_SIZE) {
-      zxdg_toplevel_v6_set_max_size(window->xdg_toplevel,
+      xdg_toplevel_set_max_size(window->xdg_toplevel,
                                     window->max_width / ctx->scale,
                                     window->max_height / ctx->scale);
     }
     if (window->maximized) {
-      zxdg_toplevel_v6_set_maximized(window->xdg_toplevel);
+      xdg_toplevel_set_maximized(window->xdg_toplevel);
     }
   } else if (!window->xdg_popup) {
-    struct zxdg_positioner_v6* positioner;
+    struct xdg_positioner* positioner;
 
-    positioner = zxdg_shell_v6_create_positioner(ctx->xdg_shell->internal);
+    positioner = xdg_wm_base_create_positioner(ctx->xdg_wm_base->internal);
     assert(positioner);
-    zxdg_positioner_v6_set_anchor(
+    xdg_positioner_set_anchor(
         positioner,
-        ZXDG_POSITIONER_V6_ANCHOR_TOP | ZXDG_POSITIONER_V6_ANCHOR_LEFT);
-    zxdg_positioner_v6_set_gravity(
+        XDG_POSITIONER_ANCHOR_TOP | XDG_POSITIONER_ANCHOR_LEFT);
+    xdg_positioner_set_gravity(
         positioner,
-        ZXDG_POSITIONER_V6_GRAVITY_BOTTOM | ZXDG_POSITIONER_V6_GRAVITY_RIGHT);
-    zxdg_positioner_v6_set_anchor_rect(
+        XDG_POSITIONER_GRAVITY_BOTTOM | XDG_POSITIONER_GRAVITY_RIGHT);
+    xdg_positioner_set_anchor_rect(
         positioner, (window->x - parent->x) / ctx->scale,
         (window->y - parent->y) / ctx->scale, 1, 1);
 
-    window->xdg_popup = zxdg_surface_v6_get_popup(
+    window->xdg_popup = xdg_surface_get_popup(
         window->xdg_surface, parent->xdg_surface, positioner);
-    zxdg_popup_v6_set_user_data(window->xdg_popup, window);
-    zxdg_popup_v6_add_listener(window->xdg_popup,
+    xdg_popup_set_user_data(window->xdg_popup, window);
+    xdg_popup_add_listener(window->xdg_popup,
                                &sl_internal_xdg_popup_listener, window);
 
-    zxdg_positioner_v6_destroy(positioner);
+    xdg_positioner_destroy(positioner);
   }
 
   if ((window->size_flags & (US_POSITION | P_POSITION)) && parent &&
@@ -1185,22 +1185,23 @@ static void sl_registry_handler(void* data,
       data_device_manager->host_global =
           sl_data_device_manager_global_create(ctx);
     }
-  } else if (strcmp(interface, "zxdg_shell_v6") == 0) {
-    struct sl_xdg_shell* xdg_shell = malloc(sizeof(struct sl_xdg_shell));
-    assert(xdg_shell);
-    xdg_shell->ctx = ctx;
-    xdg_shell->id = id;
-    xdg_shell->internal = NULL;
-    xdg_shell->host_global = NULL;
-    assert(!ctx->xdg_shell);
-    ctx->xdg_shell = xdg_shell;
+  } else if (strcmp(interface, "xdg_wm_base") == 0) {
+    struct sl_xdg_wm_base* xdg_wm_base = malloc(sizeof(struct sl_xdg_wm_base));
+    assert(xdg_wm_base);
+    xdg_wm_base->ctx = ctx;
+    xdg_wm_base->id = id;
+    xdg_wm_base->version = MIN(2, version);
+    xdg_wm_base->internal = NULL;
+    xdg_wm_base->host_global = NULL;
+    assert(!ctx->xdg_wm_base);
+    ctx->xdg_wm_base = xdg_wm_base;
     if (ctx->xwayland) {
-      xdg_shell->internal =
-          wl_registry_bind(registry, id, &zxdg_shell_v6_interface, 1);
-      zxdg_shell_v6_add_listener(xdg_shell->internal,
-                                 &sl_internal_xdg_shell_listener, NULL);
+      xdg_wm_base->internal =
+          wl_registry_bind(registry, id, &xdg_wm_base_interface, 1);
+      xdg_wm_base_add_listener(xdg_wm_base->internal,
+                                 &sl_internal_xdg_wm_base_listener, NULL);
     } else {
-      xdg_shell->host_global = sl_xdg_shell_global_create(ctx);
+      xdg_wm_base->host_global = sl_xdg_wm_base_global_create(ctx);
     }
   } else if (strcmp(interface, "zaura_shell") == 0) {
     if (version >= MIN_AURA_SHELL_VERSION) {
@@ -1307,13 +1308,13 @@ static void sl_registry_remover(void* data,
     ctx->data_device_manager = NULL;
     return;
   }
-  if (ctx->xdg_shell && ctx->xdg_shell->id == id) {
-    if (ctx->xdg_shell->host_global)
-      sl_global_destroy(ctx->xdg_shell->host_global);
-    if (ctx->xdg_shell->internal)
-      zxdg_shell_v6_destroy(ctx->xdg_shell->internal);
-    free(ctx->xdg_shell);
-    ctx->xdg_shell = NULL;
+  if (ctx->xdg_wm_base && ctx->xdg_wm_base->id == id) {
+    if (ctx->xdg_wm_base->host_global)
+      sl_global_destroy(ctx->xdg_wm_base->host_global);
+    if (ctx->xdg_wm_base->internal)
+      xdg_wm_base_destroy(ctx->xdg_wm_base->internal);
+    free(ctx->xdg_wm_base);
+    ctx->xdg_wm_base = NULL;
     return;
   }
   if (ctx->aura_shell && ctx->aura_shell->id == id) {
@@ -1476,11 +1477,11 @@ static void sl_destroy_window(struct sl_window* window) {
   }
 
   if (window->xdg_popup)
-    zxdg_popup_v6_destroy(window->xdg_popup);
+    xdg_popup_destroy(window->xdg_popup);
   if (window->xdg_toplevel)
-    zxdg_toplevel_v6_destroy(window->xdg_toplevel);
+    xdg_toplevel_destroy(window->xdg_toplevel);
   if (window->xdg_surface)
-    zxdg_surface_v6_destroy(window->xdg_surface);
+    xdg_surface_destroy(window->xdg_surface);
   if (window->aura_surface)
     zaura_surface_destroy(window->aura_surface);
 
@@ -1936,15 +1937,15 @@ static void sl_handle_configure_request(struct sl_context* ctx,
   // that matching contents will arrive.
   if (window->xdg_toplevel) {
     if (window->pending_config.serial) {
-      zxdg_surface_v6_ack_configure(window->xdg_surface,
-                                    window->pending_config.serial);
+      xdg_surface_ack_configure(window->xdg_surface,
+                                window->pending_config.serial);
       window->pending_config.serial = 0;
       window->pending_config.mask = 0;
       window->pending_config.states_length = 0;
     }
     if (window->next_config.serial) {
-      zxdg_surface_v6_ack_configure(window->xdg_surface,
-                                    window->next_config.serial);
+      xdg_surface_ack_configure(window->xdg_surface,
+                                window->next_config.serial);
       window->next_config.serial = 0;
       window->next_config.mask = 0;
       window->next_config.states_length = 0;
@@ -2065,23 +2066,23 @@ static void sl_handle_configure_notify(struct sl_context* ctx,
 static uint32_t sl_resize_edge(int net_wm_moveresize_size) {
   switch (net_wm_moveresize_size) {
     case NET_WM_MOVERESIZE_SIZE_TOPLEFT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_LEFT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT;
     case NET_WM_MOVERESIZE_SIZE_TOP:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP;
+      return XDG_TOPLEVEL_RESIZE_EDGE_TOP;
     case NET_WM_MOVERESIZE_SIZE_TOPRIGHT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_RIGHT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT;
     case NET_WM_MOVERESIZE_SIZE_RIGHT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_RIGHT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_RIGHT;
     case NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_RIGHT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT;
     case NET_WM_MOVERESIZE_SIZE_BOTTOM:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM;
+      return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM;
     case NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_LEFT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT;
     case NET_WM_MOVERESIZE_SIZE_LEFT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_LEFT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_LEFT;
     default:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_NONE;
+      return XDG_TOPLEVEL_RESIZE_EDGE_NONE;
   }
 }
 
@@ -2128,15 +2129,15 @@ static void sl_handle_client_message(struct sl_context* ctx,
         return;
 
       if (event->data.data32[2] == NET_WM_MOVERESIZE_MOVE) {
-        zxdg_toplevel_v6_move(window->xdg_toplevel, seat->proxy,
+        xdg_toplevel_move(window->xdg_toplevel, seat->proxy,
                               seat->seat->last_serial);
       } else {
         uint32_t edge = sl_resize_edge(event->data.data32[2]);
 
-        if (edge == ZXDG_TOPLEVEL_V6_RESIZE_EDGE_NONE)
+        if (edge == XDG_TOPLEVEL_RESIZE_EDGE_NONE)
           return;
 
-        zxdg_toplevel_v6_resize(window->xdg_toplevel, seat->proxy,
+        xdg_toplevel_resize(window->xdg_toplevel, seat->proxy,
                                 seat->seat->last_serial, edge);
       }
     }
@@ -2155,24 +2156,24 @@ static void sl_handle_client_message(struct sl_context* ctx,
 
       if (changed[ATOM_NET_WM_STATE_FULLSCREEN]) {
         if (action == NET_WM_STATE_ADD)
-          zxdg_toplevel_v6_set_fullscreen(window->xdg_toplevel, NULL);
+          xdg_toplevel_set_fullscreen(window->xdg_toplevel, NULL);
         else if (action == NET_WM_STATE_REMOVE)
-          zxdg_toplevel_v6_unset_fullscreen(window->xdg_toplevel);
+          xdg_toplevel_unset_fullscreen(window->xdg_toplevel);
       }
 
       if (changed[ATOM_NET_WM_STATE_MAXIMIZED_VERT] &&
           changed[ATOM_NET_WM_STATE_MAXIMIZED_HORZ]) {
         if (action == NET_WM_STATE_ADD)
-          zxdg_toplevel_v6_set_maximized(window->xdg_toplevel);
+          xdg_toplevel_set_maximized(window->xdg_toplevel);
         else if (action == NET_WM_STATE_REMOVE)
-          zxdg_toplevel_v6_unset_maximized(window->xdg_toplevel);
+          xdg_toplevel_unset_maximized(window->xdg_toplevel);
       }
     }
   } else if (event->type == ctx->atoms[ATOM_WM_CHANGE_STATE].value &&
              event->data.data32[0] == WM_STATE_ICONIC) {
     struct sl_window* window = sl_lookup_window(ctx, event->window);
     if (window && window->xdg_toplevel) {
-      zxdg_toplevel_v6_set_minimized(window->xdg_toplevel);
+      xdg_toplevel_set_minimized(window->xdg_toplevel);
     }
   }
 }
@@ -2185,7 +2186,7 @@ static void sl_handle_focus_in(struct sl_context* ctx,
     // window was realized.
     struct sl_window* parent = sl_lookup_window(ctx, window->transient_for);
     if (parent && parent->xdg_toplevel && window->xdg_toplevel)
-      zxdg_toplevel_v6_set_parent(window->xdg_toplevel, parent->xdg_toplevel);
+      xdg_toplevel_set_parent(window->xdg_toplevel, parent->xdg_toplevel);
   }
 }
 
@@ -2402,9 +2403,9 @@ static void sl_handle_property_notify(struct sl_context* ctx,
       return;
 
     if (window->name) {
-      zxdg_toplevel_v6_set_title(window->xdg_toplevel, window->name);
+      xdg_toplevel_set_title(window->xdg_toplevel, window->name);
     } else {
-      zxdg_toplevel_v6_set_title(window->xdg_toplevel, "");
+      xdg_toplevel_set_title(window->xdg_toplevel, "");
     }
   } else if (event->atom == XCB_ATOM_WM_CLASS) {
     struct sl_window* window = sl_lookup_window(ctx, event->window);
@@ -2456,19 +2457,19 @@ static void sl_handle_property_notify(struct sl_context* ctx,
       return;
 
     if (window->size_flags & P_MIN_SIZE) {
-      zxdg_toplevel_v6_set_min_size(window->xdg_toplevel,
+      xdg_toplevel_set_min_size(window->xdg_toplevel,
                                     window->min_width / ctx->scale,
                                     window->min_height / ctx->scale);
     } else {
-      zxdg_toplevel_v6_set_min_size(window->xdg_toplevel, 0, 0);
+      xdg_toplevel_set_min_size(window->xdg_toplevel, 0, 0);
     }
 
     if (window->size_flags & P_MAX_SIZE) {
-      zxdg_toplevel_v6_set_max_size(window->xdg_toplevel,
+      xdg_toplevel_set_max_size(window->xdg_toplevel,
                                     window->max_width / ctx->scale,
                                     window->max_height / ctx->scale);
     } else {
-      zxdg_toplevel_v6_set_max_size(window->xdg_toplevel, 0, 0);
+      xdg_toplevel_set_max_size(window->xdg_toplevel, 0, 0);
     }
   } else if (event->atom == XCB_ATOM_WM_HINTS) {
     struct sl_window* window = sl_lookup_window(ctx, event->window);
@@ -3581,7 +3582,7 @@ int main(int argc, char** argv) {
       .shm = NULL,
       .shell = NULL,
       .data_device_manager = NULL,
-      .xdg_shell = NULL,
+      .xdg_wm_base = NULL,
       .aura_shell = NULL,
       .viewporter = NULL,
       .linux_dmabuf = NULL,
diff --git a/vm_tools/sommelier/sommelier.h b/vm_tools/sommelier/sommelier.h
index 2d30720d3..4c7af93e8 100644
--- a/vm_tools/sommelier/sommelier.h
+++ b/vm_tools/sommelier/sommelier.h
@@ -31,7 +31,7 @@ struct sl_shell;
 struct sl_data_device_manager;
 struct sl_data_offer;
 struct sl_data_source;
-struct sl_xdg_shell;
+struct sl_xdg_wm_base;
 struct sl_subcompositor;
 struct sl_aura_shell;
 struct sl_viewporter;
@@ -99,7 +99,7 @@ struct sl_context {
   struct sl_shm* shm;
   struct sl_shell* shell;
   struct sl_data_device_manager* data_device_manager;
-  struct sl_xdg_shell* xdg_shell;
+  struct sl_xdg_wm_base* xdg_wm_base;
   struct sl_aura_shell* aura_shell;
   struct sl_viewporter* viewporter;
   struct sl_linux_dmabuf* linux_dmabuf;
@@ -377,11 +377,12 @@ struct sl_viewporter {
   struct wp_viewporter* internal;
 };
 
-struct sl_xdg_shell {
+struct sl_xdg_wm_base {
   struct sl_context* ctx;
   uint32_t id;
+  uint32_t version;
   struct sl_global* host_global;
-  struct zxdg_shell_v6* internal;
+  struct xdg_wm_base* internal;
 };
 
 struct sl_aura_shell {
@@ -481,9 +482,9 @@ struct sl_window {
   int max_height;
   struct sl_config next_config;
   struct sl_config pending_config;
-  struct zxdg_surface_v6* xdg_surface;
-  struct zxdg_toplevel_v6* xdg_toplevel;
-  struct zxdg_popup_v6* xdg_popup;
+  struct xdg_surface* xdg_surface;
+  struct xdg_toplevel* xdg_toplevel;
+  struct xdg_popup* xdg_popup;
   struct zaura_surface* aura_surface;
   struct wl_list link;
 };
@@ -527,7 +528,7 @@ struct sl_global* sl_data_device_manager_global_create(struct sl_context* ctx);
 
 struct sl_global* sl_viewporter_global_create(struct sl_context* ctx);
 
-struct sl_global* sl_xdg_shell_global_create(struct sl_context* ctx);
+struct sl_global* sl_xdg_wm_base_global_create(struct sl_context* ctx);
 
 struct sl_global* sl_gtk_shell_global_create(struct sl_context* ctx);
 
-- 
2.25.1

